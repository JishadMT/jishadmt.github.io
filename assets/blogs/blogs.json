[
  {
    "Id": 4,
    "Title": "How to copy Nuget packages with Visual Studio",
    "Description": "If you are using nuget packages in your microservices, and these nuget packages are built in a separate solution, it soon becomes hard to maintain in development environment after adding a new change to a package. Especially if the packages refer each other with a cobweb of versions. Here is how you can dump latest package version automatically after build.",
    "Tags": [
      "C#",
      "Visual Studio",
      "NuGet"
    ],
    "Image": "nuget-copy-post-build.png",
    "Date": "2025-09-21T00:00:00+05:30",
    "Link": "nuget-copy-post-build",
    "Content": "<!--!-->\n<p>Are you tired of manually copying your newly built NuGet packages to a local feed? What if you could <strong>automate</strong> this process for an entire solution without configuring each individual project? With a little MSBuild magic, you can do just that!</p><br/><h3>The Problem</h3><p>When you&#39;re developing and testing packages within a large solution, you often need to share them with other projects in the same solution or even on the same machine. Manually copying packages after every build is a repetitive and error-prone task. The traditional approach of configuring each project&#39;s build settings can quickly become a maintenance nightmare.</p><h3>The Solution: <code>Directory.Build.props</code></h3><p>MSBuild, the build engine for Visual Studio and .NET, provides a powerful feature called <strong><code>Directory.Build.props</code></strong>. This special file is automatically imported by all C# and Visual Basic projects in the directory where it&#39;s located, as well as in all subdirectories. This makes it the perfect place to centralize shared build properties.</p>\n\n<p>To solve our problem, we&#39;ll create a <code>Directory.Build.props</code> file in the root directory of our solution.</p>\n\n<p>Here&#39;s the content you&#39;ll need to add to the file:</p>\n\n<p>&nbsp;</p>\n\n<pre class=\"line-numbers\">\n        <code class=\"language-xml\">&lt;Project&gt;\n\t        &lt;PropertyGroup&gt;\n\t\t        &lt;PackageOutputPath&gt;C:\\Repos\\LocalNugetFeed&lt;/PackageOutputPath&gt;\n\t\t        &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;\n\t        &lt;/PropertyGroup&gt;\n        &lt;/Project&gt;\n</code></pre>\n\n<p>Let&#39;s break down what&#39;s happening here:</p>\n\n<ul>\n\t<li>\n\t<p><code>&lt;Project&gt;</code>: This is the root element for an MSBuild file.</p>\n\t</li>\n\t<li>\n\t<p><code>&lt;PropertyGroup&gt;</code>: This element contains a group of property definitions.</p>\n\t</li>\n\t<li>\n\t<p><code>&lt;PackageOutputPath&gt;</code>: This property specifies the <strong>output path</strong> for the generated NuGet packages. <strong>Change this value</strong> to the path of your local NuGet feed or desired destination directory.</p>\n\t</li>\n\t<li>\n\t<p><code>&lt;GeneratePackageOnBuild&gt;</code>: Setting this property to <code>true</code> instructs MSBuild to <strong>create a NuGet package</strong> for the project every time it&#39;s built.</p>\n\t</li>\n</ul>\n\n<p>After saving this file in the same directory as your <code>.sln</code> file, simply build your solution. All projects that have been configured to produce a NuGet package will now have their <code>.nupkg</code> file automatically copied to the path you specified in <code>&lt;PackageOutputPath&gt;</code>.</p><hr /><h3>The Magic Behind the Scenes&nbsp;</h3><p>When you build your solution, MSBuild looks for <code>Directory.Build.props</code> in the current directory and parent directories. It then imports the properties defined in the file. Since we&#39;ve placed it at the solution&#39;s root, its settings will be inherited by <strong>all projects</strong> within that solution.</p>\n\n<p>This approach saves you from editing individual <code>.csproj</code> files, making your build configuration more maintainable and easier to manage across a large solution.</p>\n\n<hr />\n<p>&nbsp;</p>\n\n<h3>Bonus: Configuring a Global NuGet Feed Source</h3><p>To make your local NuGet feed accessible to all projects on your machine, you need to add it as a package source in NuGet&#39;s configuration. This is a one-time setup.</p>\n\n<ol>\n\t<li>\n\t<p>Open a command prompt or terminal.</p>\n\t</li>\n\t<li>\n\t<p>Use the <code>nuget sources</code> command to add your local path as a new feed. Replace <code>C:\\Repos\\LocalNugetFeed</code> with your chosen path.</p>\n\t</li>\n</ol>\n\n<pre class=\"line-numbers\">\n        <code class=\"language-bash\">nuget sources add -name &quot;LocalFeed&quot; -source &quot;C:\\Repos\\LocalNugetFeed&quot; </code></pre>\n\n<p>You can verify that the source has been added by running:</p>\n\n<pre class=\"line-numbers\">\n        <code class=\"language-bash\">nuget sources list </code></pre>\n\n<p>Now, any project on your machine can reference packages from &quot;LocalFeed&quot; just like it would from <code>nuget.org</code>!</p>\n\n<p><!--!--></p>\n"
  },
  {
    "Id": 3,
    "Title": "Is there a better way to read value from dictionaries in C# without error?",
    "Description": "Are you using TryGetValue or ContainsKey in C# dictionaries the right way? Small choices can have big impacts on performance. Discover which approach is faster, where it shines, and how it might transform your code.",
    "Tags": [
      "c#",
      "dictionary",
      "benchmark"
    ],
    "Image": "csharp dictionary tryget vs containskey blog banner.png",
    "Date": "2024-11-22T00:00:00",
    "Link": "csharp-dictionary-containskey-vs-trygetvalue-benchmark",
    "Content": "<p>\n            When working with dictionaries in C#, retrieving a value safely and efficiently is critical, especially in performance-sensitive applications. Two common approaches for reading values safely are:\n        </p>\n        <ol>\n            <li>\n                Checking if the key exists with <code>ContainsKey</code> and then retrieving the value.\n            </li>\n            <li>\n                Using the <code>TryGetValue</code> method.\n            </li>\n        </ol>\n        <p>But which one performs better? Let's dive into the details with a benchmark comparison.</p>\n        <h5 class=\"mt-4\">\n            The two approaches\n        </h5>\n        <ol>\n            <li>\n                <div>\n                    <p><b>Using <code>ContainsKey</code> and retrieving the value</b></p>\n                    <p>\n                        This approach separates the key existence check and value retrieval:\n                    </p>\n    <pre class=\"line-numbers\">\n        <code class=\"language-csharp\">if (dictionary.ContainsKey(key))\n        {\n            var value = dictionary[key];\n            // Use the value\n        }</code>\n    </pre>\n                    <ul class=\"my-3\">\n                        <li>Performs two separate operations: key check and retrieval.</li>\n                    </ul>\n                </div>\n            </li>\n            <li>\n                <div>\n                    <p><b>Using <code>TryGetValue</code></b></p>\n                    <p>\n                        The <code>TryGetValue</code> method allows you to check for a key and retrieve its associated value in a single call:\n                    </p>\n    <pre class=\"line-numbers\">\n        <code class=\"language-csharp\">if (dictionary.TryGetValue(key, out var value))\n        {\n            // Use the value\n        }</code>\n    </pre>\n                    <ul class=\"my-3\">\n                        <li>Combines existence check and value retrieval.</li>\n                        <li>Avoids a second lookup.</li>\n                    </ul>\n                </div>\n            </li>\n        </ol>\n        \n        <h5>Why does performance differ?</h5>\n        <p>\n            At its core, a dictionary lookup involves searching for the key in its underlying hash table. In the <code>TryGetValue</code> method, this search is performed once, combining the key check and retrieval into a single operation. On the other hand, the <code>ContainsKey</code> approach searches for the key twice—once during the existence check and again during the value retrieval—leading to redundant work.\n        </p>\n        <h5>\n            Benchmarking the approaches\n        </h5>\n        <p>\n            To measure the performance difference, we set up a simple benchmark using a dictionary with a large number of entries. The benchmark tests the time taken to retrieve values using both approaches.\n        </p>\n        <p>I created the following class to benchmark the prformance of these two methods:</p>\n    <pre class=\"line-numbers\">\n        <code class=\"language-csharp\">using BenchmarkDotNet.Attributes;\n        \n        namespace Benchmarking\n        {\n            public class DictionaryUsage\n            {\n                Dictionary<string, string> dictionary;\n                const int countOfElements = 10000;\n        \n                public DictionaryUsage() \n                {\n                    // Initialize dictionary\n                    dictionary = new Dictionary<string, string>();\n                    for (int i = 0; i < countOfElements; i++)\n                    {\n                        dictionary.Add($\"key-{i}\", $\"value-{i}\");\n                    }\n        \n                }\n        \n                [Benchmark(Baseline = true)]\n                public void ReadWithoutCheck()\n                {\n                    for (int i = 0; i < countOfElements; i++)\n                    {\n                        _ = dictionary[$\"key-{i}\"];\n                    }\n                }\n        \n                [Benchmark]\n                public void ReadWithContainsKey()\n                {\n                    for(int i=0; i< countOfElements; i++)\n                    {\n                        if(dictionary.ContainsKey($\"key-{i}\"))\n                        {\n                            _ = dictionary[$\"key-{i}\"];\n                        }\n                    }\n                }\n        \n                [Benchmark]\n                public void ReadWithTryGetValue()\n                {\n                    for (int i = 0; i < countOfElements; i++)\n                    {\n                        if (dictionary.TryGetValue($\"key-{i}\", out var val))\n                        {\n                            //\n                        }\n                    }\n                }\n            }\n        }</code>\n    </pre>\n        <p>And run this program to benchmark the performance as follows:</p>\n    <pre class=\"line-numbers\">\n        <code class=\"language-csharp\">internal class Program\n        {\n            static void Main(string[] args)\n            {\n                var summary = BenchmarkRunner.Run<DictionaryUsage>();\n            }\n        }</code>\n    </pre>\n\n        <p>Here is the result of benchmark:</p>\n\n        <div class=\"text-center mb-3 mt-2\">\n            <img src=\"../assets/images/blogs/csharp dictionary tryget vs containskey benchmark result.png\" alt=\"result of the benchmark run\"/>\n        </div>\n\n        <p><b>Summary of the observations:</b></p>\n        <p>Here I took <code>ReadWithoutCheck</code> function as baseline, where we read directly from the dictionary without checking whether it has the key or not. \n            <br/>(Note: this is the most unsafe way to read value from dictionary, as it is possible that the dictionary may not contain the key-value pair you are looking for, thus throwing an exception)\n            <br/><br/>It takes <b>346 &micro;s</b> to read 10k values from the dictionary.\n        </p>\n        <ul>\n            <li>\n                <code>ReadWithContainsKey</code> function is more than 2x slower compared to baseline, taking <b>759 &micro;s</b>.\n            </li>\n            <li>\n                <code>ReadWithTryGetValue</code> function is almost as fast as baseline, taking only <b>387 &micro;s</b>.\n            </li>\n        </ul>\n\n        <p>Here, it is visibly clear that using <code>TryGetValue</code> gives a safe code at no additional performance overhead.</p>\n\n        <h5>Conclusion</h5>\n        <p>\n            The results clearly show that <code>TryGetValue</code> is the more efficient choice. By combining the key existence check and value retrieval into a single operation, it avoids the redundant key lookup that occurs with <code>ContainsKey</code>.\n            When performance matters, especially in scenarios involving frequent dictionary lookups, prefer <code>TryGetValue</code> over <code>ContainsKey</code>. It's a small change, but it can make a big difference in your application's efficiency.\n        </p>"
  },
  {
    "Id": 2,
    "Title": "Git is not picking up changes when renamed a file with upper case to lower case?",
    "Description": "Ever renamed a file in Visual Studio from uppercase to lowercase, only to find Git doesn't recognize the change? This case-insensitive quirk can disrupt your version control. Here's a quick, foolproof way to fix it, ensuring smooth tracking across all systems.",
    "Tags": [
      "git",
      "visual-studio",
      "github"
    ],
    "Image": "git mv.png",
    "Date": "2024-11-09T00:00:00",
    "Link": "renamed-file-not-picked-by-git-changes",
    "Content": "<p>\n            If you've ever renamed a file in Visual Studio, changing its case (e.g., from FILE.CS to File.cs), you may have noticed an odd quirk: Git doesn't recognize this as a change when tracked within Visual Studio. This is because Git, by default, doesn't detect case-only changes on case-insensitive file systems like Windows. Here's a quick guide on how to resolve this issue using the git mv command.\n        </p>\n        <h5 class=\"mt-4\">\n            Why Git Ignores Case Changes\n        </h5>\n        <p>\n            Git tracks files based on case-sensitive names. But on case-insensitive systems (Windows and macOS, by default), renaming from uppercase to lowercase may not trigger Git's tracking mechanism, as it treats FILE.CS and File.cs as the same file. This results in Visual Studio not showing the rename as a change, potentially causing issues when syncing with remote repositories or collaborating with team members.\n        </p>\n        <h5 class=\"mt-4\">\n            The Solution: Use <code>git mv</code>\n        </h5>\n        <p>\n            The most reliable way to ensure Git recognizes case-only renames is to use the <code>git mv</code> command. Here's what to do for renaming a file from uppercase to lowercase (or vice versa) and making sure Git tracks the change:\n        </p>\n        <pre class=\"line-numbers\">\n        <code class=\"language-bash\">git mv FILE.cs File.cs</code>\n        </pre>\n        <p>\n            Now you'll be able to see the file getting tracked in the git changes tab when you open Visual Studio.\n        </p>"
  },
  {
    "Id": 1,
    "Title": "How to delete all files in a folder ending with specific name?",
    "Description": "Managing files from the Command Prompt (CMD) can be a real time-saver, especially when you need to delete multiple files with a specific naming pattern. Let's find out how.",
    "Tags": [
      "cmd",
      "windows",
      "file"
    ],
    "Image": "del cmd.png",
    "Date": "2024-11-09T00:00:00",
    "Link": "delete-files-from-command-promt-ending-with-specific-name",
    "Content": "<p>\n                                        Managing files from the Command Prompt (CMD) can be a real time-saver, especially when you need to delete multiple files with a specific naming pattern. Let's say you want to delete all files ending with \"_copy\" – you can do this either within a single directory or across all subdirectories. Here's how to handle both scenarios using CMD.\n                                    </p>\n                                    <h5 class=\"mt-4\">\n                                        Command to delete only inside current folder\n                                    </h5>\n                                    <p>\n                                        If you only need to delete files ending with \"_copy\" in the current directory, you can use the del command directly. Open your command prompt in the current directory and enter the following:\n                                    </p>\n                                    <pre class=\"line-numbers\">\n        <code class=\"language-bash\">del *_copy.*</code>\n                                    </pre>\n                                    <p>\n                                        This command deletes all files in the current directory with names ending in _copy followed by any extension, such as file_copy.txt, image_copy.jpg, etc.\n                                    </p>\n                                    <h5 class=\"mt-4\">\n                                        Command to recursively delete from all folders inside the current folder\n                                    </h5>\n                                    <p>\n                                        If your target files are spread across subdirectories and you want to delete them all in one go, you'll need a different approach using the for loop. This method tells CMD to delete files matching the pattern across the current folder and all subfolders.\n                                    </p>\n                                    <pre class=\"line-numbers\">\n        <code class=\"language-bash\">for /r %i in (*_copy.*) do del \"%i\"</code>\n                                    </pre>\n                                    <p>\n                                        Here's what each part does:\n                                        <ul>\n                                            <li><code>for /r</code>: Searches the current directory and all subdirectories.</li>\n                                            <li><code>%i in (*_copy.*)</code>: Finds files that end with _copy and have any file extension.</li>\n                                            <li><code>do del \"%i\"</code>: Deletes each matching file it finds.</li>\n                                        </ul>\n                                    </p>\n                                    <p>\n                                        Be careful: this command deletes files permanently without a prompt, so double-check before running it.\n                                    </p>"
  }
]